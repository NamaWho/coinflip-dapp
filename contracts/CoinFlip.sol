/**
 * @author Daniel Namaki [namaki.work@gmail.com]
 */

pragma solidity 0.5.12;

import "./api/provableAPI_0.5.sol";

contract CoinFlip is usingProvable {
    uint256 public balance;
    uint256 public minimumBetAmount;

    uint256 constant NUM_RANDOM_BYTES_REQUESTED = 1;
    uint256 public latestNumber;

    struct Player {
        uint256 balance;
        uint256 betAmount;
        uint256 betChoice;
        bool isWaiting;
    }

    mapping(address => Player) public betters; //to check who's the player
    mapping(bytes32 => address) public pendingBets; //to check who's the sender of a pending bet

    event ClosedBet(
        bytes32 betId,
        address player,
        uint256 choice,
        bool victory,
        uint256 amount
    );
    event WithdrownFundsFromPlayer(
        address player,
        uint256 amount,
        uint256 contractBalance
    );
    event OccurredDeposit(address, uint256);
    event LogNewProvableQuery(string description, address sender);
    event generatedRandomNumber(uint256 randomNumber);

    modifier costsAtLeast {
        require(msg.value >= minimumBetAmount, "Not enough stake");
        _;
    }

    constructor() public payable {
        provable_setProof(proofType_Ledger);
        balance += msg.value;
        minimumBetAmount = 0.01 ether;
    }

    // @dev             place a new pending bet
    //                  update the player status
    // @param _choice   0 - Head
    //                  1 - Tails
    function placeBet(uint256 _choice) public payable costsAtLeast {
        require(
            msg.value <= balance,
            "Contract hasn't enough funds to perform this bet"
        );
        require(
            betters[msg.sender].isWaiting == false,
            "This address still has an open bet"
        );
        require(_choice <= 1, "The parameter _choice must be 0 or 1");

        betters[msg.sender].isWaiting = true;
        betters[msg.sender].betAmount = msg.value;
        betters[msg.sender].betChoice = _choice;

        update();
    }

    // @dev     call the oracle for the random number and retrieve the queryId
    //          adds a new pending bet
    function update() internal {
        uint256 QUERY_EXECUTION_DELAY = 0;
        uint256 GAS_FOR_CALLBACK = 200000; // Whenever the oracle has the response, we need to pay for the transaction to get the result in this contract

        //PRODUCTION MODE
        bytes32 queryId =
            provable_newRandomDSQuery(
                QUERY_EXECUTION_DELAY,
                NUM_RANDOM_BYTES_REQUESTED,
                GAS_FOR_CALLBACK
            );

        //DEVELOPMENT MODE (comment in production)
        //bytes32 queryId = dev_testRandomFunc();

        pendingBets[queryId] = msg.sender;

        emit LogNewProvableQuery(
            "Provable query was sent, standing by for the answer...",
            msg.sender
        );
    }

    // @dev             called by oracle, it gets the number and closes the pending bet
    // @param _queryId  used to get the bet information registered in the pendingBets mapping
    // @param _result   the random number generated by the oracle
    // @param _proof    used to verify that the result isn't corrupted
    function __callback(
        bytes32 _queryId,
        string memory _result,
        bytes memory _proof
    ) public {
        require(msg.sender == provable_cbAddress());
        require(
            provable_randomDS_proofVerify__returnCode(
                _queryId,
                _result,
                _proof
            ) == 0,
            "Call not coming from the oracle"
        );

        uint256 randomNumber =
            uint256(keccak256(abi.encodePacked(_result))) % 2;

        closeBet(_queryId, randomNumber);

        emit generatedRandomNumber(randomNumber);
    }

    // @dev     close the bet
    //          delete the bet from the pendingBets mapping
    //          update the temporary balances
    function closeBet(bytes32 _id, uint256 _result) internal returns (bool) {
        address player = pendingBets[_id];
        bool win = false;

        if (betters[player].betChoice == _result) {
            win = true;
            betters[player].balance += betters[player].betAmount * 2;
            balance -= betters[player].betAmount;
        } else {
            balance += betters[player].betAmount;
        }

        emit ClosedBet(
            _id,
            player,
            betters[player].betChoice,
            win,
            betters[player].betAmount
        );

        betters[player].isWaiting = false;
        delete pendingBets[_id];

        return win;
    }

    //DEVELOPMENT MODE (comment in production)
    // function dev_testRandomFunc() internal returns(bytes32) {
    //     bytes32 queryId = bytes32(keccak256(abi.encodePacked(msg.sender)));

    //     return queryId;
    // }

    // @dev             retrieve the temporary balance of a player
    // @param _player   address of the wanted player
    function getPlayerBalance(address _player) public view returns (uint256) {
        return betters[_player].balance;
    }

    // @dev     allow to deposit funds inside the balance of the contract
    function deposit() public payable returns (uint256) {
        balance += msg.value;

        emit OccurredDeposit(msg.sender, msg.value);

        return msg.value;
    }

    // @dev     let a player withdraw the temporary balance won with bets, if exists
    function withdrawFunds() public {
        require(msg.sender != address(0), "Inexistent address");
        require(
            betters[msg.sender].balance > 0,
            "Not enough funds to withdraw"
        );
        require(
            betters[msg.sender].isWaiting == false,
            "This address still has an open bet"
        );

        uint256 amt = betters[msg.sender].balance;
        msg.sender.transfer(amt);

        delete (betters[msg.sender]);

        emit WithdrownFundsFromPlayer(msg.sender, amt, balance);
    }

}
